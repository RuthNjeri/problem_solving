# the height of the tree is m, that is the target sum (m), the branching factor is n(number of nodes)
# O(n ^ m) Time and 0(m) Space
def can_sum(target_sum, numbers)
  return true if target_sum == 0 # 0 can be generated by taking no numbers from the array
  return false if target_sum < 0

  for num in numbers
    remainder = target_sum - num
    return true if can_sum(remainder, numbers) == true
  end

  return false
end

# Memoization
# O(m * n) T, O(m) space
def can_sum_memo(target_sum, numbers, memo = {})
  # Use target sum as the key of the memo, because the numbers array does not change
  return memo[target_sum] if !memo[target_sum].nil?
  return true if target_sum == 0 # 0 can be generated by taking no numbers from the array
  return false if target_sum < 0

  for num in numbers
    remainder = target_sum - num
    if can_sum_memo(remainder, numbers, memo) == true
      memo[target_sum] = true
      return true
    end
  end

  memo[target_sum] = false
  false
end


p can_sum_memo(7, [2, 3]) # false
p can_sum_memo(7, [5, 3, 4, 7]) # true
p can_sum_memo(7, [2, 4]) # false
p can_sum_memo(8, [2, 3, 5]) # true
p can_sum_memo(300, [7, 14]) # false
